# expireKeysControl
使用场景：有大量定时任务需要执行，定时开始的时间非常随意，取消定时任务也很随意，比如游戏报名倒计时，手动触发时取消定时任务。
三种方案：
  方案一：服务器redis放一个key，同时告诉端需要定时多长时间后请求服务器，key的过期时间是定时任务的时间，端去控制定时，到时间去请求服务器，
    服务器告诉端过期了，然后触发，这块需要控制多个端的并发问题，同时得控制业务的当前状态。
  方案二：基于redis过期key通知，需要修改redis的配置，过期key会有延时，
	  过期key失效后，再次调用后会让过期key事件通知立刻执行，这个redis是单点的，目前的集群都不支持过期key的事件通知
  方案三：将要执行的定时任务存入redis的set中，key为expire_key_task:${过期的unix时间戳}，value是每个业务定义的key， 
    每秒扫描到keys，分发到其他服务器执行，缺点也很明显，但是目前支撑每秒一万个定时key没问题。
  目前用的是方案三。我更倾向于方案一，这种随意性和用户有关，转换成用户行为最完美，但是端那边被惯坏了……
